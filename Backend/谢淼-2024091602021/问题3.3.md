# Ques 3.3

## 技巧一：灵魂容器 (内部类)

- 了解并阐述成员内部类、静态内部类、局部内部类和匿名内部类的定义、特点及适用场景。

1.成员内部类：作为成员写在外部类中的类，不使用static修饰。其中可以访问外部类的所有成员。如果需要创建成员内部类的对象，必须要先创建外部类的对象。适用于外部类无法完全描述一个对象的情况。

2.静态内部类：也是写在成员位置的内部类，但是必须使用static修饰。其中只能访问外部类的静态成员。不需要创建外部类对象，直接通过类名就可以访问静态内部类。适用于工具类等类成员功能性明显且不依赖外部类实例的场景。

3.局部内部类：写在方法或代码块中的内部类，不能使用访问修饰符限制访问范围(因为只能在这个方法或代码块中使用)，可以访问方法中的final类型局部变量。适用于封装方法内部的代码逻辑，避免对外暴露。

4.匿名内部类：没有名字的内部类，它在定义的同时就创建了实例，并且这个实例只能发挥一次作用。其中可以访问外部类的成员变量和方法。匿名内部类可以在定义的时候就实现接口或者继承父类，并且由于只执行一次的特性，常用于简化代码，重写方法/接口与事件监听。

以上四种内部类，其实都是有名字的，包括匿名内部类(只是他不会展示),可以在编译的文件中找到。

- 仔细阅读并理解下面的“建造者模式”代码。这种链式调用的构造方式，相比传统的构造方法，有何优点？（提示：参数过多、可选参数、不可变对象）

首先，传统的构造方法的参数如果太多，在编译器不提示的情况下，很难不出现记错顺序与类型的情况，这种链式构造对大多数成员都将属性具体化为方法名(比如代码中的canFly())，更容易记忆。其次，这种链式构造方式可以自由选择想要初始化的成员，其他的则设置默认值(比如代码中的favortiteFood)，相对传统的“全或无”的构造方式，更加灵活安全。最后，传统构造方法可能暴露 set 方法，导致对象状态可变，降低封装性和安全性，链式构造可以设置final类型的变量(代码中的成员变量均为final)，更安全。

## 匿名内部类应用：临时的契约实现

- 在Java 8之后，Lambda表达式让匿名内部类的使用变得更简洁。请了解常见的“函数式接口”（如`Comparator`, `Runnable`）。

有且仅有一个抽象方法的接口叫做函数式接口，一般使用@FunctionalInterface注解。

Runnable:该接口里面的唯一抽象方法是"void run() "，就像名字一样，这个接口封装一段可以被线程执行的任务逻辑。Runnable配合thread类使用可以执行异步任务，还可以应用于事件回调机制。

Comparator:是Java中自定义排序规则的函数式接口，加载于sort中，其中包含一个方法：int compare(T o1,T o2)，其中T是一个泛型，可以是各种类型的比较。返回负数，0，正数分别代表o1<o2,o1==o2,o1>o2.在调用时可以自由重写需要的排序规则。

- 对你的宠物列表，分别使用“匿名内部类”、“Lambda表达式”和“方法引用”这三种方式，实现一个`Comparator`，按年龄进行排序。

问题3.3_匿名内部类.png

问题3.3_lambda.png

问题3.3_方法引用.png

==遇到问题==：lambda表达式的排序时报错，但是语法并没有问题

==解决方式==：重新配置JDK且清除缓存过后解决。

## 技巧二：设计模式的智慧

- 你的宠物店需要一个全局唯一的“交互管理器”（`InteractionManager`）来处理所有宠物之间的互动。如果每个人都能随便创建一个，世界就乱套了。“单例模式”确保了这种唯一性。请了解其概念和至少两种实现方式（如懒汉式、饿汉式）。

单例模式：确保某个对象在一个系统中只有一个实例，随处可以调用。

懒汉式：类加载时就创建实例。饿汉式：调用类的时候才创建实例。

- 为你的宠物系统设计并实现一个单例的`InteractionManager`

验证：问题3.3_单例模式.png

```java
public class InteractionManager {
    private static InteractionManager instance;
    private InteractionManager(){}
    public static InteractionManager getInstance() {
        if(instance==null){
            instance=new InteractionManager();
        }
        return instance;
    }
    public void interact(Pet pet) {
        System.out.println("与"+pet.getName()+"互动中...");
        pet.eat();
        pet.speak();
    }
}
```

- 了解策略模式，并重构你的`InteractionManager`，将具体的交互逻辑（如`play`, `compete`）设计成可替换的策略

策略模式允许将每种交互行为封装成独立的策略类，并在运行时手动替换，从而让交互管理器保持简洁。

验证：问题3.3_策略模式.png

交互管理器：

```java
public class InteractionManager {
    private static InteractionManager instance;
    private InteractionManager(){}
    private InteractionStrategy strategy;
    public static InteractionManager getInstance() {
        if(instance==null){
            instance=new InteractionManager();
        }
        return instance;
    }
    public void setStrategy(InteractionStrategy strategy){
        this.strategy=strategy;
    }
    public void interact(Pet p1,Pet p2) {
        if(strategy==null){
            System.out.println("没有设置交互策略");
        }else {
            strategy.interact(p1,p2);
        }
    }
}
```

策略类：

```java
public class PlaywithEach implements InteractionStrategy{
    @Override
    public void interact(Pet p1, Pet p2) {
        System.out.println(p1.getName()+"和"+p2.getName()+"友好玩耍");
        p1.speak();
        p2.speak();
    }
}
class CompeteforFood implements InteractionStrategy{
    @Override
    public void interact(Pet p1, Pet p2) {
        System.out.println(p1.getName()+"和"+p2.getName()+"为食物争斗");
        p1.speak();
        p2.speak();
    }
}
class MagicBattle implements InteractionStrategy{
    @Override
    public void interact(Pet p1, Pet p2) {
        System.out.println(p1.getName()+"和"+p2.getName()+"魔法对决");
    }
}
```

策略接口：

```java
public interface InteractionStrategy {
    public void interact(Pet p1,Pet p2);
}
```

==遇到问题==：其实最开始直接在InteractionManager里写了很多ifelse，但是这样不符合让内容更简洁的目的。

==解决方法==：改用重写接口方法。

- 了解工厂方法模式，并设计一个`PetFactory`，将你系统中创建各种宠物的逻辑统一管理起来。

工厂方法模式是一种创建型设计模式，它将对象的创建过程封装在一个工厂类中，允许子类决定实例化哪一个类。

测试：问题3.3_工厂方法模式.png

```java
public class PetFactory {
    public static Pet CreatePet(Pet p,String name,int age,String gender){
        if(p instanceof British_Blues){
            return new British_Blues(name,age,gender);
        }else if(p instanceof Orange) {
            return new Orange(name,age,gender);
        }else if(p instanceof Hasky) {
            return new Hasky(name,age,gender);
        }else if(p instanceof Teddy){
            return new Teddy(name,age,gender);
        }else{
            System.out.println("无法创建该宠物");
            return null;
        }
    }
}
```