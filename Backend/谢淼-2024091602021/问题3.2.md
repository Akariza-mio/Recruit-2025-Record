# Ques 3.2

# 第一定律：灵魂守护 (封装)

## 构建守护结界

- 学习并运用Java的“访问控制符”（`public`, `protected`, `private`），为你的宠物蓝图构建起坚固的守护结界。

public修饰的成员是公开的，无论是否在一个包中，都可以访问此成员，protected可以表示"受保护的"，它修饰的成员只有在当前包和这个类的所有子类才可以访问，private表示"私有的"，只有在本类中才可以获取访问。初次之外，还有一个默认访问权限，即”什么也不写“，这个权限的成员只对同一个包开放，所以也叫"包访问权限"，访问范围从大到小:public>protected>默认>private.如果我不想让别人修改宠物的年龄，我可以这样写：private int age;

- 深刻阐述为何“封装”是构建一个安全、可控系统的基石

封装的核心是信息隐藏，它让系统的内部实现细节对外部调用者不可见，只暴露必要的调用入口。这样的设计将类或接口本身与无关人员隔离开，并且无法被轻易修改，大大提升了代码的复用性和程序模块化程度，使得调试与维护更快捷简单(不会因为一个bug全部崩溃)。在访问控制符的修饰下，封装的系统更加稳定，被封装的系统内部逻辑不对外人展示，可以降低被攻击的风险。在可控方面，封装降低了系统运维时的难度，减少了注意事项，做到了真正的面向对象，就好比开车，只需要掌握车的开法，而不是发动机的工作原理。同时，封装的系统更方便后续的更新演化，大大提升了产品生命周期，方便拓展各种架构。

## 规范的能量交换

- 为你的宠物蓝图中的私有属性，设计公开的“读取”（get）和“修改”（set）方法。当然，你也可以设计更有趣的交互方式，比如`feed(Food food)`来增加饱食度，而不是简单的`setHunger()`

```java
public class MagicCat {
    private String name;
    private int age;
    private int hunger;
    public MagicCat() {}
    public MagicCat(String name, int age,int hunger) {
        this.name=name;
        this.age=age;
        this.hunger=hunger;
    }
    public void backward_somersault(){
        System.out.println(this.age+"岁的"+this.name+"使出了后空翻！");
    }
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public int getHunger() {
        return hunger;
    }
    public void Feed(String food) {
        switch (food) {
            case "fish"->{
                hunger+=20;
            }
            case "string"->{
                hunger+=5;
            }
            case "catfood"->{
                hunger+=10;
            }
            case "rottedmeat"->{
                hunger-=10;
            }
            default ->{
                hunger+=2;
            }
        }
    }
}
```

运行：问题3.2_宠物的setget.png

## 种族天赋 (静态static)

-  有些属性和能力是属于整个“种族”的，而非某个体。这就是“静态”魔法。请探究`static`关键字的奥秘，理解静态变量、静态方法和静态代码块。

static是创建成员变量或方法时，写在访问控制符之后，返回类型与变量类型之前的一个关键字。static代表这个变量或方法是"静态的",也就是这个变量或方法是属于这个类本身的，它和这个类平起平坐，在创建类的时候就存在，所有此类的对象都共享static修饰的成员，访问这个成员的时候也不需要创建对象，而是可以直接通过类名访问。一般对于所有对象的公认共有的一些性质和行为，可以设置为静态，比如一所学校的所有学生对象可以共享同一个学校名字，静态的方法则一般属于工具类，这个类中是手动编写的可以直接调用的工具方法，而静态代码块是写在static{}的代码块，它在这段程序的生命中只会执行一次，并且和类的加载同时进行，可以用来初始化静态变量或者进行静态资源配置。

- 运用静态变量和构造仪式，为你的每个宠物种族（`MagicCat`类、`SpiritDog`类等）实现一个计数器，统计各种族当前被创造出的个体数量。

```java
    private static int count=0;
    public MagicCat() {
        ++count;
    }
    public MagicCat(String name, int age,int hunger) {
        ++count;
        this.name=name;
        this.age=age;
        this.hunger=hunger;
    }
    public static int getCount(){
        return count;
    }
```

验证：问题3.2_static验证.png

==遇到问题==：验证时无法直接得到count的返回值。

==解决方法==：count前面用private修饰，但count为了防止被乱改就应该用private修饰，故添加了getCount()方法。

# 第二定律：血脉传承 (继承)

## 绘制生命之树

- 学习Java的“继承”（`extends`）魔法，理解其核心特性。

继承允许一个类“继承”另一个类的所有的非私有的成员变量和方法，在继承的一瞬间，这个类就成为被继承类的子类，自动拥有父类所有的非私有的成员变量和方法。在java中是单继承，一个子类只能拥有一个父类。子类可以重写父类的方法，在创建子类的对象后调用的将是被重写后的方法。构造方法不会被子类继承，但是在子类创建对象的时候会自动调用父类的构造方法，它是隐藏的。继承还是实现多态的基础：父类的引用可以创建子类的对象。

- 子类如何“觉醒”自己的独特能力（重写父类方法）？

只有父类存在同名方法，传入的参数和返回类型完全一致，并且修饰符不是private/final/static的时候才可以重写这个方法。重写的方法需要尽量加上@Override作为标志，方便检查和告诉别人(不写也不会报错)。重写方法可以提供子类相对于父类本质相同但更适合自己的方法，即"定制"子类自己的行为。重写标准是内容可变，其他都不能变(返回类型，传入参数等).子类重写的方法不可以缩小父类的访问范围。

- 在子类的构造仪式中，如何借助`super`和`this`关键字，调用父辈的力量？

首先，调用构造方法的目的是给新创建的对象初始化成员变量。对于一个子类的构造方法可以是基本的this.xx=新值,也可以是this.setxx(),更可以直接this(xx)，都可以完成初始化。但由于super的存在，它可以调用直接父类的构造方法，即如果子类继承的父类变量仍需要沿用，那么可以在子类的构造方法里写super(xx)，这样也可以更方便地完成初始化。需要注意的是，super只能写在子类构造函数的第一行（因为本身默认也是第一行），必须最先被调用。

- 什么是“抽象蓝图”（抽象类）？它在构建生命之树时有何妙用？

含有抽象方法（abstract修饰）的类就是抽象类。其中可以包括不抽象的成员变量，构造方法和方法，但只要一个方法是抽象的，这个类就是抽象类，抽象类不能创建对象。抽象方法是没有具体实现代码的，它以(){}结尾，并且这个方法在子类中必须重写。抽象类在继承体系中起到”子类的行为模板“的作用，它规定子类必须实现一些方法的重写，是提供了一些可继承成员的抽象行为规范，利于构建层次化的继承体系。

## 构建你的宠物家族

- 请参考但不限于下面的继承关系图，设计并构建你自己的宠物继承体系。例如，创建一个所有宠物的始祖`Pet`类，然后派生出`Feline`（猫科）、`Canine`（犬科）等，再往下细分。 (可在此处插入原有的类继承图)

==遇到问题==：这里好像并没有题上说的”下图“。

==解决方式==：并不影响做题。

类继承图：问题3.2_类继承图.png

```java
public abstract class Pet{
    private String name;
    private int age;
    private String gender;
    public Pet(){}
    public Pet(String name,int age,String gender) {
        this.name=name;
        this.age=age;
        this.gender=gender;
    }
    public abstract void eat();
    public abstract void speak();
    public String getName() {
        return name;
    }
    public void setName(String name) {
        this.name = name;
    }
    public int getAge() {
        return age;
    }
    public void setAge(int age) {
        this.age = age;
    }
    public String getGender() {
        return gender;
    }
    public void setGender(String gender) {
        this.gender = gender;
    }
}
class Feline extends Pet{
    public Feline(){}
    public Feline(String name,int age,String gender) {
        super(name,age,gender);
    }
    @Override
    public void eat(){
        System.out.println("吃鱼");
    }
    @Override
    public void speak(){
        System.out.println("meow");
    }
}
class Canine extends Pet{
    public Canine(){}
    public Canine(String name,int age,String gender) {
        super(name,age,gender);
    }
    @Override
    public void eat(){
        System.out.println("吃骨头");
    }
    @Override
    public void speak(){
        System.out.println("woof");
    }
}
class British_Blues extends Feline{
    private String color="blue";
    public British_Blues(){}
    public British_Blues(String name,int age,String gender) {
        super(name,age,gender);
    }
    public String getColor(){
        return color;
    }
    public void bite(){
        System.out.println("咬数据线");
    }
}
class Orange extends Feline{
    private String color="orange";
    public Orange(){}
    public Orange(String name,int age,String gender) {
        super(name,age,gender);
    }
    public String getColor(){
        return color;
    }
    public void lazy(){
        System.out.println("发呆");
    }
}
class Teddy extends Canine{
    public Teddy(){}
    public Teddy(String name,int age,String gender) {
        super(name,age,gender);
    }
    public void ceng(){
        System.out.println("蹭一下");
    }
}
class Hasky extends Canine{
    public Hasky(){}
    public Hasky(String name,int age,String gender) {
        super(name,age,gender);
    }
    public void des(){
        System.out.println("破坏");
    }
}
```

# 第三定律的补充：契约魔法 (接口)

## 签订能力契约

-  学习Java的“接口”（`interface`）魔法，理解其如何定义一种“能力规范”。

接口是java的一种机制，他就像是”魔法书“,可以让实现接口的类瞬间掌握接口中定义的方法。对于一些情况，单纯的继承不能完美的表述对象之间应有的行为，比如有的人会游泳，有的狗也会游泳，但人和狗不能存在继承关系，这时就需要接口将游泳的行为分别单独实现。接口中定义的方法默认是抽象的，即和抽象类相似，只定义而不描述，这也代表着接口的实现类必须要重写接口中的方法。同时，接口中也不能包含实例变量，但是可以包含static final的常量。

- 接口与抽象类有何本质区别？

首先，接口不是类。接口是通过implements连接类的一种抽象行为标准，可以自由定义行为与连接的实现类，还可以进行多连接，定义行为规范更加独立，自由，而抽象类存在于继承体系当中，其中可以包含继承体系中需要的各种方法，变量，代码架构上更加复杂，并且与子类密不可分，只能单继承，相对来说更加体系化。接口只能定义常量，抽象类可以定义实例变量。

## 赋予你的宠物超能力

- 请自行设计`Flyable`, `Swimmable`, `Healable`等能力接口，并让你的宠物们通过签订契约（实现接口）来获得这些强大的能力。

接口定义：

```java
public interface Flyable {
    public void fly();
} 
interface Swimmable{
    public void swim();
}
interface Healable{
    public void heal();
}
```

==遇到问题==：在一个接口文件命名多个public接口报错

==解决方式==:一个接口文件里只声明一个public接口(建议还是单独写，但是这样比较方便)

实现类：

```java
class British_Blues extends Feline implements Flyable{
    private String color="blue";
    public British_Blues(){}
    public British_Blues(String name,int age,String gender) {
        super(name,age,gender);
    }
    public String getColor(){
        return color;
    }
    public void bite(){
        System.out.println("咬数据线");
    }
    @Override
    public void fly(){
        System.out.println("蓝猫飞起来！");
    }
}
class Orange extends Feline implements Swimmable{
    private String color="orange";
    public Orange(){}
    public Orange(String name,int age,String gender) {
        super(name,age,gender);
    }
    public String getColor(){
        return color;
    }
    public void lazy(){
        System.out.println("发呆");
    }
    @Override
    public void swim(){
        System.out.println("橘猫会游泳了");
    }
}
class Teddy extends Canine implements Flyable,Healable{
    public Teddy(){}
    public Teddy(String name,int age,String gender) {
        super(name,age,gender);
    }
    public void ceng(){
        System.out.println("蹭一下");
    }
    @Override
    public void fly(){
        System.out.println("泰迪飞起来！");
    }
    @Override
    public void heal(){
        System.out.println("泰迪自动回血");
    }
}
class Hasky extends Canine implements Swimmable{
    public Hasky(){}
    public Hasky(String name,int age,String gender) {
        super(name,age,gender);
    }
    public void des(){
        System.out.println("破坏");
    }
    @Override
    public void swim(){
        System.out.println("哈士奇会游泳了");
    }
}
```

验证:问题3.2_接口.png

# 第三定律：万物归一 (多态)

## 理解多态的无处不在

- 在Java魔法中，多态体现在方方面面。请至少理解并阐述以下几种场景：父类引用指向子类实例、方法重写、接口引用指向实现类实例

父类引用指向子类实例：对于Father a=new Son()这样的对象创建，因为Son类型是Father类型的子类，所以Son自然就是“兼容“Father的，就像现实中我们会说，“学生也是人”，这种话就是多态的体现，在java中，父类引用之所以可以指向子类实例，是因为他们本身有继承关系，所以可以“向上转型”。

方法重写：重写父类方法。若a调用Father与Son同签名的方法，则会执行Son中重写的方法,因为new出来的其实是Son的对象，a它先是Son,然后才送给Father兼容，所以会调用子类的方法。

接口引用指向实现类实例：与上面的那个例子相同，只是现在变成了“接口名 a=new 实现类()；”，类比接口名为父类，实现类为子类，它们自然也是"兼容"的，并且这个a实际上是实现类对象，调用同名方法依旧调用实现类中的重写方法。

此外其实还有传入参数的多态，标注传入父类形参时，实际传入子类也可以，同理可以推广到接口和实现类。

- 当你用一个“始祖”（`Pet`）的眼光看待所有宠物时，如何分辨出它真正的形态？学习`instanceof`关键字的探知魔法。

当使用Pet创建子类对象后，根据对象名看不出究竟是什么类型，可以“变量名 instanceof 类名”判断，如果这个变量确实是这个类或这个类的子类，就返回true,否则返回false.这里的类名一般尽可能的低级，这样才可以实现更精确的判断，然后如果有需要可以进行强制类型转化。

问题3.2_instanceof.png

## 命运的随机宠物

- 请补全下面的代码。当一个新玩家来到你的宠物店时，系统将随机赠送他一只宠物。你需要运用多态和`instanceof`，让他知道自己获得了什么，并展示该宠物的独特叫声

主函数：

```java
import java.util.Random;

public class PetStoreOpening {
    public static void main(String[] args) {
        Random random = new Random();
        int choice = random.nextInt(3); // 随机选择 0, 1, 或 2

        Pet newCompanion=null; // 使用你的宠物始祖类

        // TODO: 根据随机数choice，为newCompanion实例化一只具体的宠物 (如MagicCat, SpiritDog, BabyDragon)
        switch (choice) {
            case 0:
                newCompanion = new MagicCat();
                break;
            case 1:
                newCompanion = new SpiritDog();
                break;
            case 2:
                newCompanion = new BabyDragon();
                break;
        }

        // TODO: 使用instanceof判断newCompanion的真实形态，并向玩家宣布
        // 例如: "恭喜你，获得了一只神奇的魔法猫！"
        if(newCompanion instanceof MagicCat){
            System.out.println("恭喜你，获得了一只神奇的魔法猫!");
        }else if(newCompanion instanceof SpiritDog){
            System.out.println("恭喜你，获得了精神狗(?)!");
        }else if(newCompanion instanceof BabyDragon){
            System.out.println("恭喜你，获得了幼龙！");
        }

        // TODO: 调用一个被子类重写的方法 (如makeSound())，展现多态的魅力
        newCompanion.makeSound(); // 魔法猫会“喵~”，灵魂犬会“汪！”，幼龙会“嗷~
    }
}
```

类：

```java
class MagicCat extends Pet{
    @Override
    public void makeSound(){
        System.out.println("喵~");
    }
}
class SpiritDog extends Pet{
    @Override
    public void makeSound(){
        System.out.println("汪！");
    }
}
class BabyDragon extends Pet{
    @Override
    public void makeSound(){
        System.out.println("嗷~");
    }
}
```

测试：问题3.2_多态.png

==遇到问题==：newCompanion未初始化报错，但是我们都知道它一定会被赋值的。

==解决方法==：赋值了一个null.