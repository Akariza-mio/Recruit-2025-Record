# Ques1.2:

## 探寻指针的踪迹

- 你可能听说过C语言中那把锋利无比的“指针”之剑。在Java的魔法世界里，是否存在同样的东西？

Ans: Java中并不存在指针这样的实例工具，但却有相似的”引用“机制。

- Java中的“引用”究竟是什么？与指针相比，这种设计为我们的世界带来了什么（例如，安全性和简便性）？

Ans: Java中的引用其实指的是对内存地址的引用，或者说“替代”。在Java中无法像c语言直接使用指针显式操作地址，但java的引用有同样的含义：指向这个对象的内存地址。我们在创建一个对象时，其实变量保存的并不是这个对象本身，而是创建对象开辟的地址，我们对于这个对象的所有操作，都需要先通过这个引用的地址找到它在内存中的位置，然后对其进行操作，这是与指针不同的地方：指针可以直接加减运算，通过解引用得到内容，但Java中只能引用。这样的设计更加安全：Java的引用不允许直接操作地址，也不允许释放内存。垃圾回收器会自动清理不再使用的对象，极大减少了内存泄漏的风险。同时当然也更加简便：我们不用像写c语言一样绞尽脑汁安排内存的分配，也不用考虑指针指向的内容是否合法，或者野指针与空指针的存在遗留的问题，并且不用的对象会被java自动回收，不需要再去free出内存。还有一点，这样的设计使得人们更加方便的考虑“对象与对象的关系”，而不是“极致的性能与内存安排”，体现了Java面向对象的特点。

==遇到问题==：为了这个问题还特地去复习了c语言的指针......遂解决。

-  一个经典的魔法辩题：Java中的参数传递，究竟是“值传递”还是“引用传递”？请阐述你的观点。

Ans:归根结底，java中的参数传递是值传递。这里需要分成两种情况讨论，第一种是传递的参数是基本数据类型，第二种是传递引用类型。对于第一种情况，把基本数据类型传递进来时，其实只是相当于把传进来的”值“赋给了这个形参，并在方法中进行一系列运用，可以由代码验证(assets\问题1.2的验证1.png)：如果这里输出了10，说明在方法中把这个地址中的值都修改了，但事实不是这样，这个代码输出5，因此这种情况是值传递。第二种情况，当传递了一个引用类型进来，这里假设为对象，当它被当成形参传递进来后，它实际传递的是这个对象的副本，也就是它的引用的内存地址"值"，通过代码验证(assets\问题1.2的验证2.png),如果是引用传递，那么p1会被修改成一个新的地址值，之后会输出b,但事实上输出了a,因为这个参数指定的地址值的改变不会通过方法传递到全局，它不会改变引用本身，则原地址还是不变的，故输出a.

## 引用的四重形态

Java中的引用并非铁板一块，它有四种不同的强度等级（强、软、弱、虚）

- 请探究这四种引用形态的特性，以及它们在何种情况下会自动断开与对象的连接。

1.强引用：强引用是默认的引用类型，几乎所有的对象都是强引用类型，且垃圾回收器永远不会回收强引用类型。只有在强行把对象设置为null后才会断开(死亡即是终点),其他时候永远不会断开引用连接。

2.软引用：软引用的强度次于强引用，这体现在它在大部分情况下不会被回收，只有在内存不足的时候可能会被回收，为系统腾出内存空间。

3.弱引用：弱引用的强度次于软引用，它一旦被垃圾回收器扫描到就会被回收(随时可能会被回收)。

4.虚引用：引用等级最下，它是唯一不能访问对象的引用强度，必须配合ReferenceQueue使用。

- 它们各自适用于哪些特殊的魔法场景？（例如：构建缓存、监控对象回收）

1.强引用：最常用的引用强度，是java代码的核心，适合用于核心业务代码构建与对象创建。

2.软引用：由于内存紧张才被回收的特殊机制，它十分适合用于“可重建但代价高”的对象，比如浏览器的缓存(图片，视频等),加载高清的图片十分耗费内存，因此可以构建缓存空间来软引用图片的对象。

3.弱引用：WeakHashMap是最常见的应用场景，这个哈希表中的键就是弱引用类型，如果这个键不再被其他地方引用，就会自动从哈希表删除。

4.虚引用：此引用类型无法访问对象，可以作为监控对象回收的标志：当检测到这个对象马上要被回收，这个对象的虚引用就会被加入ReferenceQueue，标志它即将被清除。

==遇到问题==：在运行虚引用的示例代码时，程序并没有执行清理逻辑，并且运行超时。

==解决方法==：经排查，未给临时对象解除强引用，手动设置resource=null后成功运行。

## 实践中的洞察

- Java世界为了安全，不允许魔法师直接操作内存地址。我们的一切操作都是通过“引用”这根魔杖完成的。请思考：为何Java要采用这种模式？ 接下来，请在不运行下方代码的情况下，预测它的输出，并从Java内存模型（尤其是字符串常量池和栈、堆的交互）的角度，详细解释你的答案

就像题干所说，Java采用这种模式的理由之一就是为了安全，在避免了人为操作内存之后，Java的程序变得简单又安全，并且Java有自己的内存管理机制：垃圾回收器。另外的一个主要原因就是，Java是一门面向对象的语言，在摒弃了指针这样的工具后，开发者的重心会放在思考“对象与对象之间的关系”与“更加和谐好用的代码”上，大大提高了代码的可维护性与项目开发效率。这段代码会输出“hello"。原因：在方法外，开始在栈内存中执行main方法，创建str同时也给其赋值了字面量，这样的字面量会被存放在字符串常量池中，因为它写在代码中，是编译的时候就存在的。而对于方法内创建的新对象s+" world"，即“hello world”,它并不会被放在串池中，而是在堆中开辟一个新内存，因为String类型的值是”不可变的“，新对象不会覆盖原地址中的内容，这是Java规定好的。又由于Java值传递的特性，这个新对象只会把地址值赋给方法中的s,但这个s的生命就到此为止了，不会被带出方法外，因此str本身从开始到结束一直就没变过，都是串池中的"hello".如果想实现得到“hello world"的效果，只需要换成可变类型的对象即可(assets\问题1.2的验证3.png).