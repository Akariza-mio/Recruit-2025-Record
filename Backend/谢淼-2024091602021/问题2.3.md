# Ques 2.3

## 激活二叉树的思维脉络

- 请简要说明“二叉树”这种数据结构的核心特点。

二叉树首先是图，然后是树，树是节点之间不会形成环的图，并且具有层级结构，即每一层中间节点都有自己的父节点和子节点，树的最高层的节点只有一个，叫做树的根，它没有父节点，最底层的叫做叶，它没有子节点，而二叉树就是每个节点最多有两个子节点的树。

- 对于一个给定的二叉树，魔法师有三种主要的探知其内部结构的方式：前序、中序和后序遍历。请你使用“递归”这一优雅的魔法，实现这三种遍历方式，并揭示树中所有节点的秘密。

```java
class TreeNode {
    int val; // 节点蕴含的能量值
    TreeNode left, right; // 指向左右两个思维分支的引用
    TreeNode(int val) { this.val = val; }
}

public class BinaryTreeTraversal {

    // 构建一个样本智慧核心
    public static TreeNode buildSampleTree() {
        TreeNode root=new TreeNode(1);
        root.left=new TreeNode(2);
        root.right=new TreeNode(3);
        root.left.left=new TreeNode(4);
        root.left.right=new TreeNode(5);
        root.right.right=new TreeNode(6);
        return root;
    }

    // 前序遍历（核心 -> 左分支 -> 右分支）
    public static void preorder(TreeNode node) {
        if(node==null)return;
        System.out.print(node.val+" ");
        preorder(node.left);
        preorder(node.right);
    }
    // 中序遍历（左分支 -> 核心 -> 右分支）
    public static void inorder(TreeNode node) {
        if(node==null)return;
        inorder(node.left);
        System.out.print(node.val+" ");
        inorder(node.right);
    }
    // 后序遍历（左分支 -> 右分支 -> 核心）
    public static void postorder(TreeNode node) {
        if(node==null)return;
        postorder(node.left);
        postorder(node.right);
        System.out.print(node.val+" ");
    }

    // 魔法测试
    public static void main(String[] args) {
        TreeNode root = buildSampleTree();
        System.out.print("前序探知：");
        preorder(root); // 预期输出: 1 2 4 5 3 6
        System.out.println();

        System.out.print("中序探知：");
        inorder(root); // 预期输出: 4 2 5 1 3 6
        System.out.println();

        System.out.print("后序探知：");
        postorder(root); // 预期输出: 4 5 2 6 3 1
    }
}
```

==遇到问题==:其实需要先推一下这个二叉树的结构。

==解决方式==：手动验证了输出结果asset\问题2.3_二叉树.png

验证：asset\问题2.3_输出结果.png