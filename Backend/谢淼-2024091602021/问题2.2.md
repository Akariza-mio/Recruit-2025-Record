# Ques 2.2

## 构建后进先出的能量井 (MyStack)

- 基于数组或链表（可使用Java内置的`LinkedList`），构建一个自定义的栈 `MyStack`。

```java
public class MyStack {
    LinkedList<Integer> stack = new LinkedList<Integer>();
    public MyStack() {}
    public void push(int value) {
        stack.add(x);
    }
    public int pop(){
        if(stack.size()==0){
            System.out.println("栈空！无法弹出");
        }
        int tp=stack.getLast();
        stack.removeLast();
        return tp;
    }
    public int peek(){
        if(stack.size()==0){
            System.out.println("栈空！无法查看");
        }
        return stack.getLast();
    }
    public boolean isEmpty(){
        if(stack.size()==0)return true;
        return false;
    }
}
```

数组需要确定大小（动态数组应该不在讨论范围......），故用LinkedList类实现。运行测试asset\问题2.2_栈测试.png

==遇到问题==：在栈空时调用pop()或peek()，这时理应写一个报错提示，但是题上的方法固定了返回值为int，那栈空的时候返回什么呢？

==解决方式==：开始想的是返回-1，但是-1也是一个int类型的数啊，栈中有它也不是奇怪的事,然后想返回一个特殊的数代表错误，比如32202(ERROR),但这和-1又是一个道理。后来想直接抛出错误：NoSuchElementException，但是这样程序会强制终止(assets\问题2.2_空栈.png)，那反正都要报错的，干脆手动sout一个提示算了。

## 构建先进先出的能量通道 (MyQueue)

- 基于链表（可使用Java内置的`LinkedList`）实现一个自定义队列 `MyQueue`。

```java
public class MyQueue {
    LinkedList<Integer> stack = new LinkedList<Integer>();
    public MyQueue() {}
    public void enqueue(int value) {
        stack.add(value);
    }
    public int dequeue(){
        if(stack.size()==0){
            System.out.println("队列空！无法出队");
        }
        int tp=stack.getFirst();
        stack.removeFirst();
        return tp;
    }
    public int peek(){
        if(stack.size()==0){
            System.out.println("队列空！无法查看");
        }
        return stack.getFirst();
    }
    public boolean isEmpty(){
        if(stack.size()==0)return true;
        return false;
    }
}
```

沿用了上面栈的代码。测试：assets\问题2.2_队列测试.png

## 魔法的变通与溯源

- 思考一下，你能否只用“能量井”（栈）来模拟出“能量通道”（队列）的效果？反之，用“能量通道”能否模拟“能量井”？请阐述你的思路，无需编码。

用栈模拟队列，其实就是把一个口变成两个口，自然就需要两个栈，一个pushstack负责入，一个popstack负责出。实现原理：最开始两个栈都为空，入队开始后，自然加入pushstack,直到有出队的需求时，因为队列的特性，我们需要弹出pushstack中最里面的元素，此时将pushstack的元素倒序加入popstack，之后再按顺序pop即可，注意的地方是，每次需要检测popstack是否为空，为空的时候才需要倒序加入pushstack的元素。

用队列模拟栈的原理跟用栈模拟队列相似，只需要把一个方向变成两个方向，依旧需要两个队列，一个q1，一个q2。在入栈开始时正常放入q1,直到需要出栈，再把q1中的元素不断出，直到q1只剩下一个元素，这个元素就是栈顶,之后重复这样的方式。还可以直接使用双端队列，尾进尾出即可。

- 在Java的官方魔法库中，是否存在现成的“栈”与“队列”实现？若有，它们是如何构建的？与你亲手打造的相比，有何异同与优劣

存在。

Java的Stack类继承自动态数组Vector,它的push和pop本质上是addElement和removeElementAt(size()-1).

Queue是一个接口，它最常见的实现类是LinkedList,通过连接接口使得LinkedList获得了队列的特殊行为，但本质上还是调用LinkedList的方法。

与手写相比，这些库中的成品集合了许多的java特性，有更高的安全性，易用性和方便性，并且优化了性能，但手写的相对更加自由，并且可以按照自己的需要定义功能，更加方便拓展和节约内存。

