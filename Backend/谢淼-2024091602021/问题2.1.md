# Ques 2.1:

## 理解生命形态

- 首先，请简要阐述“链表”这种生命形态的本质，并与静态的“数组”进行对比，说明其独特的优势（如动态伸缩）。

链表是一种线性数据结构，由于一个个节点头尾相连，特别像一条链子而得名。链表的节点和数组一样，都可以储存特定的对象或值，但不同在于，链表的节点还必须包含“指针域”，表示与其相连的节点。链表相对数组的优势在于，它不需要提前确定长度，可以随时在任意位置增加，修改，删除节点，这样既提高了运行效率，又节省了内存开销。

## 铸造链接核心

- 现在，请你亲手实现一个名为 `MyLinkedList` 的自定义单向链表类。你需要为它赋予以下核心能力:

（1）`void add(int value)`: 在生命的末端追加一个新的光点（节点）。

（2） `void insert(int index, int value)`: 在指定位置（索引）精准植入一个新的光点。

（3） `int get(int index)`: 读取并返回指定位置光点的能量值（value）。

（4） `void remove(int index)`: 熄灭并移除指定位置的光点。

（5） `int size()`: 感知并返回当前生命形态包含的光点总数。



```java
public class MyLinkedList {
    private static class node{
        int value;
        node next;
        node(int value){
            this.value = value;
            this.next = null;
        }
    }
    private node head;
    private node tail;
    private int list_size;
    public MyLinkedList() {
        head = null;
        tail = null;
        list_size=0;
    }
    public void add(int value){
        node tp=new node(value);
        if(head==null){
            head=tp;
            tail=tp;
        }else{
            tail.next=tp;
            tail=tp;
        }
        list_size++;
    }
    public void insert(int index,int value){
        if(index<=0||index>1+list_size){
            System.out.println("索引越界");
            return;
        }
        node tp=new node(value);
        if(index==1+list_size){
            if(tail==null){
                head=tp;
                tail=tp;
            } else {
                tail.next=tp;
                tail=tp;
            }
        }else if(index==1){
            tp.next=head;
            head=tp;
            if(list_size==0){
                tail=tp;
            }
        }else{
            node prev=head;
            for(int i=1;i<index-1;++i){
                prev=prev.next;
            }
            tp.next=prev.next;
            prev.next=tp;
        }
        list_size++;
    }
    public int get(int index){
        if(index<=0||index>list_size){
            System.out.println("索引越界");
            return -1;
        }
        node prev=head;
        for(int i=1;i<index;++i){
            prev=prev.next;
        }
        return prev.value;
    }
    public void remove(int index){
        if(index<=0||index>list_size){
            System.out.println("索引越界");
            return;
        }
        if(index==1){
            head=head.next;
            if(list_size==1){
                head=null;
                tail=null;
            }
        }else{
            node prev=head;
            for(int i=1;i<index-1;++i){
                prev=prev.next;
            }
            if(prev.next==tail){
                tail=prev;
            }
            prev.next=prev.next.next;
        }
        list_size--;
    }
    public int size(){
        return list_size;
    }
}
```
这个链表的起始索引是1.
## 生命测试

- 为你的 `MyLinkedList` 编写测试魔法，确保它的每一项能力都如你预期般精确无误。



```java
public class test1 {
    public static void main(String[] args) {
        MyLinkedList list = new MyLinkedList();

        System.out.println("测试空链表");
        System.out.println("当前大小: " + list.size());
        System.out.println("尝试获取第1个元素: " + list.get(1)); // 越界
        list.remove(1); // 越界

        System.out.println("\n测试add方法");
        list.add(10);
        list.add(20);
        list.add(30);
        printList(list); // 应该输出 10 20 30

        System.out.println("\n测试insert方法");
        list.insert(1, 5);   // 头部插入
        list.insert(3, 15);  // 中间插入
        list.insert(6, 35);  // 尾部插入
        printList(list);     // 应该输出 5 10 15 20 30 35

        System.out.println("\n测试get方法");
        for (int i = 1; i <= list.size(); i++) {
            System.out.println("第" + i + "个元素: " + list.get(i));
        }

        System.out.println("\n测试remove方法");
        list.remove(1); // 删除头部
        list.remove(3); // 删除中间
        list.remove(list.size()); // 删除尾部
        printList(list); // 应该输出 10 15 30

        System.out.println("\n测试越界插入和删除");
        list.insert(0, 100); // 越界
        list.insert(10, 200); // 越界
        list.remove(0); // 越界
        list.remove(10); // 越界

        System.out.println("\n最终链表状态");
        printList(list);
        System.out.println("最终大小: " + list.size());
    }

    public static void printList(MyLinkedList list) {
        for (int i = 1; i <= list.size(); i++) {
            System.out.print(list.get(i) + " ");
        }
        System.out.println();
    }
}
```

==遇到问题==：在测试时发现了许多的NullPointerException错误。

==解决方法==：添加了尾指针，并且严谨的调试了尾指针的变化方式，同时优化了尾插法的效率(不用循环再找节点了)。运行结果assets\问题2.1测试1.png

## 赋予生命逆转时空的能力

- 实现一个 `reverse()` 方法，让你的链式生灵能够瞬间反转自身结构。请简要阐述你实现这一高级魔法的思路。

```java
public void reverse(){
    if(list_size<=1){
        return;
    }
    node prev=null;
    node cur=head;
    node next=null;
    while(cur!=null){
        next=cur.next;
        cur.next=prev;
        prev=cur;
        cur=next;
    }
    tail=head;
    head=prev;
}
```

这个方法定义在MyLinkedList中。

这个方法的思路：反转一个链表，其实就是反转指针指向。三个指针分别代表前，当前节点，后。初始时只有cur有值，进入循环当中，next自动指向cur的下一个节点，代表移动方向，同时cur的next指向prev，代表反转这个节点的指针，反转结束后，就要移动剩下的指针，因此prev=cur,cur=next.最后再交换头节点和尾节点。实例：asset\问题2.1运行实例1.png

==遇到问题==：其实想过能不能直接交换第n个和倒数第n个数......因为node的成员只有int类型嘛，但是仔细想了一下，题好像没有让我在链表里写一个修改value值的方法，这是一个陷阱吗？

==解决方式==：用三指针法代替。


